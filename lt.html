<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full-Screen Linear Transformation Visualizer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars */
        }
        /* Style for the canvas to be fixed and cover the whole screen */
        #transformationCanvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
            background-color: #f8fafc;
        }
        /* Style for the floating control panel */
        .control-panel {
            position: fixed;
            top: 2rem;
            left: 2rem;
            z-index: 10;
        }
        /* Styling for the matrix input to look like a matrix */
        .matrix-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            align-items: center;
            background-color: #f1f5f9;
            padding: 0.5rem;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
        }
        .matrix-container::before,
        .matrix-container::after {
            content: '';
            display: block;
            width: 8px; /* Width of the bracket */
            border-radius: 4px;
            background-color: #94a3b8;
        }
        .matrix-container::before {
            grid-column: 1 / 1;
            grid-row: 1 / 3;
            border-right: 4px solid #f1f5f9;
        }
         .matrix-container::after {
            grid-column: 4 / 4;
            grid-row: 1 / 3;
            border-left: 4px solid #f1f5f9;
        }
        .matrix-inputs {
            grid-column: 2 / 4;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Canvas for full-screen visualization -->
    <canvas id="transformationCanvas"></canvas>

    <!-- Floating Control Panel -->
    <div class="control-panel bg-white/80 backdrop-blur-sm rounded-xl shadow-lg p-6 w-full max-w-sm">
        <div class="text-left mb-6">
            <h1 class="text-2xl font-bold text-gray-900">Linear Transformation</h1>
            <p class="text-gray-600 mt-1">Watch the vector and the grid transform in real-time.</p>
        </div>

        <div class="flex flex-col space-y-6">
            <!-- Vector Input -->
            <div>
                <label for="vectorX" class="block text-sm font-medium text-gray-700 mb-1">Original Vector</label>
                <div class="flex items-center space-x-2 bg-gray-100 p-2 rounded-lg border border-gray-300">
                    <span class="font-mono text-lg text-gray-500">[</span>
                    <input type="number" id="vectorX" value="2" class="w-full p-2 text-center bg-transparent focus:outline-none font-mono text-lg">
                    <span class="font-mono text-lg text-gray-500">,</span>
                    <input type="number" id="vectorY" value="3" class="w-full p-2 text-center bg-transparent focus:outline-none font-mono text-lg">
                    <span class="font-mono text-lg text-gray-500">]</span>
                </div>
            </div>

            <!-- Matrix Input -->
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Transformation Matrix</label>
                <div class="matrix-container">
                    <div class="matrix-inputs">
                        <input type="number" id="matrixA" value="1" class="w-full p-2 text-center bg-white rounded-md border border-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-lg">
                        <input type="number" id="matrixB" value="-1" class="w-full p-2 text-center bg-white rounded-md border border-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-lg">
                        <input type="number" id="matrixC" value="1" class="w-full p-2 text-center bg-white rounded-md border border-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-lg">
                        <input type="number" id="matrixD" value="1" class="w-full p-2 text-center bg-white rounded-md border border-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-lg">
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex space-x-4">
                <button id="transformButton" class="flex-1 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-300 ease-in-out shadow-md hover:shadow-lg">
                    Transform
                </button>
                <button id="resetButton" class="flex-1 bg-gray-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all duration-300 ease-in-out shadow-md hover:shadow-lg">
                    Reset
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element Selection ---
        const canvas = document.getElementById('transformationCanvas');
        const ctx = canvas.getContext('2d');
        const transformButton = document.getElementById('transformButton');
        const resetButton = document.getElementById('resetButton');
        const inputs = {
            vecX: document.getElementById('vectorX'),
            vecY: document.getElementById('vectorY'),
            matA: document.getElementById('matrixA'),
            matB: document.getElementById('matrixB'),
            matC: document.getElementById('matrixC'),
            matD: document.getElementById('matrixD')
        };

        // --- Canvas & Drawing Configuration ---
        let origin = { x: 0, y: 0 };
        const scale = 40; // Pixels per unit
        const staticGridColor = '#e5e7eb'; // Lighter color for the static grid
        const gridColor = '#d1d5db';
        const axisColor = '#6b7280';
        const originalVectorColor = '#3b82f6'; // Blue
        const transformedVectorColor = '#ef4444'; // Red

        // --- State Variables ---
        let animationFrameId;
        const identityMatrix = [[1, 0], [0, 1]];
        let currentMatrix = [[1, 0], [0, 1]];

        // --- Core Functions ---

        /**
         * Resizes the canvas to fill the window and sets the origin.
         */
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            origin = { x: canvas.width / 2, y: canvas.height / 2 };
            drawScene(); // Redraw everything on resize
        }
        
        /**
         * Applies a matrix transformation to a point.
         */
        function applyMatrix(point, matrix) {
            return {
                x: matrix[0][0] * point.x + matrix[0][1] * point.y,
                y: matrix[1][0] * point.x + matrix[1][1] * point.y
            };
        }

        /**
         * Draws the untransformed, static grid as a reference.
         */
        function drawStaticGrid() {
            ctx.strokeStyle = staticGridColor;
            ctx.lineWidth = 1;
            const unitsWidth = Math.ceil(canvas.width / scale);
            const unitsHeight = Math.ceil(canvas.height / scale);

            // Draw vertical lines
            for (let i = -unitsWidth; i <= unitsWidth; i++) {
                ctx.beginPath();
                ctx.moveTo(origin.x + i * scale, 0);
                ctx.lineTo(origin.x + i * scale, canvas.height);
                ctx.stroke();
            }
            // Draw horizontal lines
            for (let i = -unitsHeight; i <= unitsHeight; i++) {
                ctx.beginPath();
                ctx.moveTo(0, origin.y + i * scale);
                ctx.lineTo(canvas.width, origin.y + i * scale);
                ctx.stroke();
            }
        }

        /**
         * Draws the transformed coordinate grid and axes.
         */
        function drawTransformedGrid(matrix) {
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;

            const unitsWidth = Math.ceil(canvas.width / scale);
            const unitsHeight = Math.ceil(canvas.height / scale);

            // Draw transformed vertical lines
            for (let i = -unitsWidth; i <= unitsWidth; i++) {
                ctx.beginPath();
                let startPoint = applyMatrix({ x: i, y: -unitsHeight }, matrix);
                ctx.moveTo(origin.x + startPoint.x * scale, origin.y - startPoint.y * scale);
                for (let j = -unitsHeight * 2; j <= unitsHeight * 2; j++) {
                    let p = applyMatrix({ x: i, y: j / 2 }, matrix);
                    ctx.lineTo(origin.x + p.x * scale, origin.y - p.y * scale);
                }
                ctx.stroke();
            }

            // Draw transformed horizontal lines
            for (let i = -unitsHeight; i <= unitsHeight; i++) {
                ctx.beginPath();
                let startPoint = applyMatrix({ x: -unitsWidth, y: i }, matrix);
                ctx.moveTo(origin.x + startPoint.x * scale, origin.y - startPoint.y * scale);
                for (let j = -unitsWidth * 2; j <= unitsWidth * 2; j++) {
                    let p = applyMatrix({ x: j / 2, y: i }, matrix);
                    ctx.lineTo(origin.x + p.x * scale, origin.y - p.y * scale);
                }
                ctx.stroke();
            }

            // Draw main axes (also transformed)
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            // X-axis
            ctx.beginPath();
            let startXAxis = applyMatrix({x: -unitsWidth, y: 0}, matrix);
            ctx.moveTo(origin.x + startXAxis.x * scale, origin.y - startXAxis.y * scale);
            for (let i = -unitsWidth * 2; i <= unitsWidth * 2; i++) {
                 let p = applyMatrix({ x: i/2, y: 0 }, matrix);
                 ctx.lineTo(origin.x + p.x * scale, origin.y - p.y * scale);
            }
            ctx.stroke();
            // Y-axis
            ctx.beginPath();
            let startYAxis = applyMatrix({x: 0, y: -unitsHeight}, matrix);
            ctx.moveTo(origin.x + startYAxis.x * scale, origin.y - startYAxis.y * scale);
            for (let i = -unitsHeight * 2; i <= unitsHeight * 2; i++) {
                 let p = applyMatrix({ x: 0, y: i/2 }, matrix);
                 ctx.lineTo(origin.x + p.x * scale, origin.y - p.y * scale);
            }
            ctx.stroke();
        }

        /**
         * Draws a vector on the canvas with an arrowhead.
         */
        function drawVector(vector, color) {
            const startX = origin.x;
            const startY = origin.y;
            const endX = origin.x + vector.x * scale;
            const endY = origin.y - vector.y * scale; // Canvas y-coordinate is inverted

            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            const angle = Math.atan2(endY - startY, endX - startX);
            const headlen = 12;
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        /**
         * Gathers current values from all input fields.
         */
        function getInputs() {
            return {
                vector: {
                    x: parseFloat(inputs.vecX.value) || 0,
                    y: parseFloat(inputs.vecY.value) || 0,
                },
                matrix: [
                    [parseFloat(inputs.matA.value) || 0, parseFloat(inputs.matB.value) || 0],
                    [parseFloat(inputs.matC.value) || 0, parseFloat(inputs.matD.value) || 0],
                ]
            };
        }

        /**
         * Draws the static scene: a standard grid and the current vector.
         */
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTransformedGrid(currentMatrix);
            const { vector } = getInputs();
            const transformedVector = applyMatrix(vector, currentMatrix);
            drawVector(transformedVector, transformedVectorColor);
        }

        /**
         * Handles the transformation process.
         */
        function handleTransform() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            const { vector: startVector, matrix: targetMatrix } = getInputs();
            // Animate from the current state to the new target state
            animateTransformation(startVector, currentMatrix, targetMatrix);
        }
        
        /**
         * Handles resetting the transformation.
         */
        function handleReset() {
             if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            const { vector: startVector } = getInputs();
            // Animate from the current state back to the identity matrix
            animateTransformation(startVector, currentMatrix, identityMatrix);
        }

        /**
         * Animates the grid and vector from a start matrix to a target matrix.
         */
        function animateTransformation(startVec, startMatrix, targetMatrix) {
            const duration = 1500; // 1.5 second animation
            let startTime = null;
            
            function animationLoop(currentTime) {
                if (!startTime) startTime = currentTime;
                
                const elapsedTime = currentTime - startTime;
                let progress = Math.min(elapsedTime / duration, 1);
                progress = 0.5 - 0.5 * Math.cos(progress * Math.PI); // Ease in-out

                // Interpolate matrix from start to target
                const intermediateMatrix = [
                    [
                        (1 - progress) * startMatrix[0][0] + progress * targetMatrix[0][0],
                        (1 - progress) * startMatrix[0][1] + progress * targetMatrix[0][1]
                    ],
                    [
                        (1 - progress) * startMatrix[1][0] + progress * targetMatrix[1][0],
                        (1 - progress) * startMatrix[1][1] + progress * targetMatrix[1][1]
                    ]
                ];

                const intermediateVector = applyMatrix(startVec, intermediateMatrix);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawStaticGrid();
                drawTransformedGrid(intermediateMatrix);
                drawVector(intermediateVector, transformedVectorColor);

                if (progress < 1) {
                    animationFrameId = requestAnimationFrame(animationLoop);
                } else {
                    // Final draw to ensure it ends perfectly and update the current state
                    currentMatrix = targetMatrix;
                    drawScene();
                }
            }
            animationFrameId = requestAnimationFrame(animationLoop);
        }

        // --- Event Listeners ---
        transformButton.addEventListener('click', handleTransform);
        resetButton.addEventListener('click', handleReset);
        Object.values(inputs).forEach(input => input.addEventListener('input', drawScene));
        window.addEventListener('resize', resizeCanvas);

        // --- Initial Setup ---
        resizeCanvas();
    </script>
</body>
</html>
